# Repository Agent Instructions

- Run `source .venv/bin/activate && pytest` before doing anything and note which tests are currently failing. Don't try to fix those tests unless they are directly related to the problem.
- Don't make any changes that the user did not specify.
- Prefer running tests with `source .venv/bin/activate && pytest` from the repository root unless a different command is specified.
- Keep documentation changes up to date with code changes.
- Follow PEP 8 style guidelines for Python code.
- Run `source .venv/bin/activate && mypy` when type-safety is affected or after non-trivial Python changes.
- Run `source .venv/bin/activate && black .` before sending changes that touch Python files.
- Use `source .venv/bin/activate && python` when running repo-local Python scripts.
- The `mltt.kernel` module implements a miniature Martin-Löf type theory.
- The `mltt.ind` module implements several common inductives such as `Nat`, `Vec`, `Fin`, `Maybe`, `List`, `Bool`, `Sigma`, `Eq`, `Unit`, `Empty`, and others.
- The `mltt.surface` module implements a parser and elaborator for surface syntax.
- De Bruijn strategy: binders push indices outward (0 = innermost). Context entries are stored relative to their tails and shifted on lookup; extending a context prepends new binders without rewriting existing entry types. Substitutions decrement indices above the target and shift the inserted term when descending under binders. Inductive parameters are outermost, followed by indices, then constructor arguments; utilities expect substitutions in that order and rely on consistent shifting.
- `mltt.kernel.ast`:
  - `Term` is the base class for all kernel terms and owns shifting/substitution, normalization/whnf, and type-checking helpers. `TermFieldMeta.binder_count` drives correct shifting/substitution under binders; `unchecked=True` skips structural equality checks.
  - `Term` public methods: `shift` (raise free vars above cutoff), `subst` (replace `Var(j)`), `instantiate` (substitute a binder block with `ArgList` actuals), `inst_levels` (instantiate universe levels), `whnf_step` (one-step weak-head reduction), `whnf` (normalize to WHNF), `normalize_step` (one reduction anywhere), `normalize` (full normalization), `infer_type` (synthesize type), `type_check` (check against a type), `expect_universe` (require `Type(u)`), `type_equal` (definitional equality), `__str__` (pretty-print).
  - `TermFieldMeta(binder_count, unchecked)` annotates dataclass fields for binder depth and type-equality checks.
  - `Var(k)`: `k` is a de Bruijn index (0 = innermost). `Var.subst` removes the binder (`k > j` decrements); `Var.shift` bumps indices at/above cutoff.
  - `MetaVar(mid)`: `mid` is the elaboration metavariable id.
  - `Lam(arg_ty, body)`: `body` is under one binder (`binder_count=1`).
  - `Pi(arg_ty, return_ty)`: `return_ty` is under one binder (`binder_count=1`).
  - `App(func, arg)`: reduces by beta if the head is a `Lam`; type inference checks `Pi` and substitutes the argument into the codomain.
  - `UApp(head, levels)`: universe application; `head` must be `Const`, `Ind`, `Ctor`, or local `Var`; checks `uarity` and instantiates the head type.
  - `Univ(level)`: `Type(level)` with `Type(l)` : `Type(l+1)` and level consistency checks.
  - `Let(arg_ty, value, body)`: `body` is under one binder at `Var(0)`; inference uses `Env.push_let`.
  - `Term.instantiate(actuals, depth_above)` substitutes an outer binder block with `actuals` using the project order: higher indices first (outermost actuals map to larger indices).
- `mltt.kernel.tel` (outermost-to-innermost ordering throughout):
  - `ArgList` is an argument list in left-to-right application order; `decompose_app` returns args in that same order.
  - `Telescope` is a list of binder types ordered outermost → innermost; helpers treat the first element as outermost.
  - `mk_app(fn, *args)` applies term arguments left-associatively, flattening `ArgList` items.
  - `mk_lams(*param_tys, body)` (lambda tower) and `mk_pis(*param_tys, return_ty)` (Pi tower) take parameters outermost → innermost so the last parameter is closest to the body.
  - `decompose_app(term)` splits an application into `(head, ArgList)` in original argument order.
  - `mk_uapp(head, levels, *args)` applies universe levels before term arguments; `decompose_uapp(term)` splits `(head, levels, ArgList)`.
  - `ArgList.vars(n, offset)` returns `Var(n-1)..Var(0)` (outermost → innermost) with an optional offset; this is used to reconstruct parameter/field variables.
  - `instantiate` on `Telescope` shifts `depth_above` by the binder index, so each successive telescope entry is substituted with the correct de Bruijn depth.
- `mltt.kernel.env` (innermost-to-outermost for `Env.binders`):
  - `Env.binders[0]` is the innermost binder; `push_binder`/`push_let` prepend without rewriting existing entry types.
  - `push_binders` expects outermost → innermost input, so the last pushed binder ends up at index 0.
  - `local_type(k)` shifts stored types by `k+1` because entries are scoped in the tail; `local_value(k)` returns let-bound definitions when present.
  - `lookup_local` finds the nearest name (innermost first); `names()` returns binder names ordered by de Bruijn index.
  - `GlobalDecl` includes `ty`, optional `value`, `reducible`, and `uarity` for universe parameters.
- `mltt.kernel.ind` (parameters outermost, then indices, then fields/args; all inductive classes are `Term` subclasses):
  - `Ind` stores `param_types`, `index_types`, `constructors`, `level`, and `uarity`; `infer_ind_type` builds a Pi-tower `params → indices → Type(level)` with universe checks.
  - `Ctor` stores `inductive`, `field_schemas`, `result_indices`, and `uarity`; `infer_ctor_type` builds a Pi-tower with parameters outermost, then ctor fields, returning the inductive head applied to params/indices.
  - `Elim` stores `inductive`, `motive`, `cases`, and `scrutinee`; it performs iota-reduction when the scrutinee WHNF is a fully-applied constructor and `infer_elim_type` checks motive/cases and constructs expected branch types with fields then IHs.
- `mltt.surface.prelude`:
  - `register_value` adds a `GlobalDecl` for a computed value by inferring its type in an env built from current globals; `uarity` is copied from the value when present.
  - `prelude_globals` builds the default global environment mapping names like `Nat`, `Bool`, `List`, `Vec`, `Fin`, `Maybe`, and `Sigma` (plus their constructors) to `GlobalDecl` entries.
  - `prelude_env` returns an `Env` seeded with the prelude globals.
- This codebase is not a public library—feel free to make breaking changes when needed; no backwards compatibility shims are required.
- Tests live under `tests/mltt/` and mirror the source tree—add or update the relevant modules when behaviour changes.
